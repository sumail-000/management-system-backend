---
alwaysApply: true
---

NOTE: These are not just only rules , these are just one of the rules that apply on this project for now just only these .

Rule 1: Whenever a user wants to add or remove something in the database table, instead of creating a separate migration file for that task, work on the original migration file that created the table. It's not good practice to create a whole new migration file for just a simple task, so follow best practice by editing the existing original table creation file. When running migrations after making changes, only refresh/update the specific affected table's migration rather than running a full migration that would reset all tables. This ensures other database tables remain untouched while only the modified table gets updated. Strictly follow this throughout the project without breaking character.


Rule 2: When a user requests not to start the server automatically, do not execute server commands from the terminal without explicit approval. If you need to share server run commands in chat, do so without executing them. For example, if you make changes and need to check if they work, do not immediately run the server using auto-execute commands (even if previously granted for fast development). If the user interrupts and asks not to start the server until requested, strictly follow this instruction and wait for user approval before starting the server. This applies to all similar scenarios where server execution is involved.



Rule 3: user want to make any changes in the database table structure then strictly follow the rule 1 and rule 2.




Rule 4: When a user requests to analyze, explore, or understand any aspect of the project (including features, functionality, logic, issues, implementations, files, or folders), thoroughly fulfill this request first. After gaining understanding through this analysis, use this knowledge to address any subsequent requests for changes, new features, or bug fixes. There is no need to re-examine the codebase for information you've already analyzed - utilize your existing understanding from the previous analysis. Only perform additional code investigation if you encounter aspects not covered in the initial analysis. This approach ensures efficiency and maintains context while handling user requests.



Rule 5: User Interruptions and Context Awareness

When a user interrupts your response, it typically indicates one of the following:
1. The user has identified an important consideration
2. You may have deviated from the intended direction
3. There could be a potential error in your approach

In such cases:
- Immediately stop and carefully consider the user's intervention
- Maintain awareness of the previous conversation context and actions
- Analyze the reason for the interruption by connecting it to prior interactions
- Adjust your response according to the user's guidance
- Remember that interruptions are purposeful and indicate something requires attention

This approach ensures proper alignment with user requirements and helps prevent potential misunderstandings or incorrect implementations.




Rule 6: CRITICAL - Maintain Contextual Continuity and Action History

It is imperative to maintain complete awareness of the conversation history and associated actions throughout the development process. This includes:

1. Preserving context between all interactions and their relationships
2. Tracking both dialogue exchanges and corresponding implementation actions
3. Maintaining ability to accurately reverse or modify previous changes when requested
4. Understanding the full scope and impact of each user request within the project context

Example: When a user requests code deletion or feature removal, maintain detailed tracking of these changes to enable precise restoration if needed. This principle extends beyond simple undo operations - it requires comprehensive understanding of how each action relates to both previous and potential future modifications.

This rule is fundamental to ensuring development continuity and preventing context loss that could lead to implementation errors or inconsistencies. No action should be taken without full consideration of its relationship to the existing conversation and action history.



Rule 7: Frontend Consistency and UI Integrity

When handling frontend-related requests, exercise extreme caution and precision, as modifications can significantly impact the overall user interface and functionality. Follow these critical guidelines:

1. Analysis Requirements:
   - Thoroughly examine existing UI implementations
   - Review current styling patterns and aesthetic choices
   - Understand the context of the specific component or area being modified

2. Implementation Standards:
   - Maintain strict consistency with established design patterns
   - Follow existing styling conventions for new elements
   - Preserve the visual harmony of the interface

3. Component Integration:
   - When adding new components or fields, inherit styling attributes from similar existing elements
   - Ensure seamless integration with surrounding UI elements
   - Maintain responsive behavior across different screen sizes

4. Default Behavior:
   - In absence of specific styling instructions, strictly adhere to existing design patterns
   - Do not introduce out-of-context or inconsistent visual elements
   - Preserve the established user experience flow

This rule ensures frontend modifications maintain the application's visual cohesion and functional integrity while preventing unintended UI disruptions.



NOTE: These are not just only rules , these are just one of the rules that apply on this project for now just only these .

Rule 1: Whenever a user wants to add or remove something in the database table, instead of creating a separate migration file for that task, work on the original migration file that created the table. It's not good practice to create a whole new migration file for just a simple task, so follow best practice by editing the existing original table creation file. When running migrations after making changes, only refresh/update the specific affected table's migration rather than running a full migration that would reset all tables. This ensures other database tables remain untouched while only the modified table gets updated. Strictly follow this throughout the project without breaking character.


Rule 2: When a user requests not to start the server automatically, do not execute server commands from the terminal without explicit approval. If you need to share server run commands in chat, do so without executing them. For example, if you make changes and need to check if they work, do not immediately run the server using auto-execute commands (even if previously granted for fast development). If the user interrupts and asks not to start the server until requested, strictly follow this instruction and wait for user approval before starting the server. This applies to all similar scenarios where server execution is involved.



Rule 3: user want to make any changes in the database table structure then strictly follow the rule 1 and rule 2.




Rule 4: When a user requests to analyze, explore, or understand any aspect of the project (including features, functionality, logic, issues, implementations, files, or folders), thoroughly fulfill this request first. After gaining understanding through this analysis, use this knowledge to address any subsequent requests for changes, new features, or bug fixes. There is no need to re-examine the codebase for information you've already analyzed - utilize your existing understanding from the previous analysis. Only perform additional code investigation if you encounter aspects not covered in the initial analysis. This approach ensures efficiency and maintains context while handling user requests.



Rule 5: User Interruptions and Context Awareness

When a user interrupts your response, it typically indicates one of the following:
1. The user has identified an important consideration
2. You may have deviated from the intended direction
3. There could be a potential error in your approach

In such cases:
- Immediately stop and carefully consider the user's intervention
- Maintain awareness of the previous conversation context and actions
- Analyze the reason for the interruption by connecting it to prior interactions
- Adjust your response according to the user's guidance
- Remember that interruptions are purposeful and indicate something requires attention

This approach ensures proper alignment with user requirements and helps prevent potential misunderstandings or incorrect implementations.




Rule 6: CRITICAL - Maintain Contextual Continuity and Action History

It is imperative to maintain complete awareness of the conversation history and associated actions throughout the development process. This includes:

1. Preserving context between all interactions and their relationships
2. Tracking both dialogue exchanges and corresponding implementation actions
3. Maintaining ability to accurately reverse or modify previous changes when requested
4. Understanding the full scope and impact of each user request within the project context

Example: When a user requests code deletion or feature removal, maintain detailed tracking of these changes to enable precise restoration if needed. This principle extends beyond simple undo operations - it requires comprehensive understanding of how each action relates to both previous and potential future modifications.

This rule is fundamental to ensuring development continuity and preventing context loss that could lead to implementation errors or inconsistencies. No action should be taken without full consideration of its relationship to the existing conversation and action history.



Rule 7: Frontend Consistency and UI Integrity

When handling frontend-related requests, exercise extreme caution and precision, as modifications can significantly impact the overall user interface and functionality. Follow these critical guidelines:

1. Analysis Requirements:
   - Thoroughly examine existing UI implementations
   - Review current styling patterns and aesthetic choices
   - Understand the context of the specific component or area being modified

2. Implementation Standards:
   - Maintain strict consistency with established design patterns
   - Follow existing styling conventions for new elements
   - Preserve the visual harmony of the interface

3. Component Integration:
   - When adding new components or fields, inherit styling attributes from similar existing elements
   - Ensure seamless integration with surrounding UI elements
   - Maintain responsive behavior across different screen sizes

4. Default Behavior:
   - In absence of specific styling instructions, strictly adhere to existing design patterns
   - Do not introduce out-of-context or inconsistent visual elements
   - Preserve the established user experience flow

This rule ensures frontend modifications maintain the application's visual cohesion and functional integrity while preventing unintended UI disruptions.



